import re
from typing import Optional, List
from datetime import datetime
from decimal import Decimal
from pydantic import BaseModel, Field, field_validator
from src.application.domain.validator.date_validator import DateValidator
from src.application.domain.validator.amount_validator import AmountValidator
from src.application.domain.utils.status_types import Status


class ExtractedExpense(BaseModel):
    title: str = Field(
        ...,
        min_length=1,
        max_length=100,
        description="Name or title of the product/service found in the invoice.",
        examples=["Office Chair"]
    )
    description: Optional[str] = Field(
        None,
        max_length=255,
        description="Detailed description of the item, if available.",
        examples=["Ergonomic black office chair with lumbar support"]
    )
    quantity: Decimal = Field(
        ...,
        description="The quantity of items purchased.",
        examples=[1.0]
    )
    unit_price: Decimal = Field(
        ...,
        description="The price per unit of the item.",
        examples=[150.50]
    )
    total_amount: Decimal = Field(
        ...,
        description="The total calculated amount (quantity * unit_price).",
        examples=[150.50]
    )
    date: Optional[str] = Field(
        None,
        description="The date of the transaction in YYYY-MM-DD format.",
        examples=["2023-10-25"]
    )
    category_id: Optional[str] = Field(
        None,
        description="The ID of the category associated with this expense (optional).",
        examples=["cat_12345"]
    )
    access_key: Optional[str] = Field(
        None,
        description="The 44-digit access key from the NFe (Electronic Invoice).",
        examples=["35230912345678000195550010000000011000000001"]
    )
    is_duplicate: bool = Field(
        False,
        description="Flag indicating if this item has been identified as a duplicate."
    )
    duplicate_of_id: Optional[str] = Field(
        None,
        description="If duplicate, the ID of the original task/expense."
    )

    @field_validator('title', 'description', mode='before')
    @classmethod
    def clean_strings(cls, v):
        return str(v).strip() if v else None

    @field_validator('quantity', 'unit_price', 'total_amount', mode='before')
    @classmethod
    def parse_amount(cls, v):
        return AmountValidator.validate(v)

    @field_validator('date', mode='before')
    @classmethod
    def parse_date(cls, v):
        return DateValidator.validate_and_format(v)

    @field_validator('access_key', mode='before')
    @classmethod
    def clean_access_key(cls, v):
        if not v: return None
        return re.sub(r'\D', '', str(v))

class ExtractionError(BaseModel):
    item_identifier: str = Field(
        ...,
        description="Identifier of the item or line where the error occurred.",
        examples=["Line 5", "Item IA: MacBook Pro"]
    )
    error_message: str = Field(
        ...,
        description="A human-readable error message explaining why the extraction failed.",
        examples=["Invalid date format", "Missing required field: total_amount"]
    )

class ExtractionTask(BaseModel):
    id: Optional[str] = Field(
        None,
        description="Unique identifier of the extraction task (auto-generated by DB).",
        examples=["653a1b2c3d4e5f6g7h8i9j0k"]
    )
    filename: str = Field(
        ...,
        description="Original name of the uploaded file.",
        examples=["invoice_october.pdf"]
    )
    file_type: str = Field(
        ...,
        description="The extension or MIME type of the file.",
        examples=["pdf", "jpg", "xlsx"]
    )
    file_hash: Optional[str] = Field(
        None,
        description="SHA-256 hash of the file content to prevent duplicate processing."
    )
    status: Status = Field(
        Status.PENDING,
        description="Current processing status of the task."
    )
    user_id: str = Field(
        ...,
        description="The ID of the user who owns this task."
    )
    created_at: datetime = Field(
        default_factory=datetime.now,
        description="Timestamp when the task was created."
    )
    updated_at: datetime = Field(
        default_factory=datetime.now,
        description="Timestamp when the task was last updated."
    )
    result_data: List[ExtractedExpense] = Field(
        [],
        description="List of successfully extracted items."
    )
    error_report: List[ExtractionError] = Field(
        [],
        description="List of errors encountered during processing."
    )

    class Config:
        use_enum_values = True
